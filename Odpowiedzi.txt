1.Zidentyfikuj dług technologiczny w sytuacji gdyby prototyp miał trafić do użytkowników w obecnej formie.
2.Jak dodałbyś persistent storage?
3.Jak rozwiązałbyś uwierzytelnianie?
4.Jak zapewniłbyś skalowalność względem ilości użytkowników?
5.Jak rozwiązałbyś potrzebę biznesową zdjęcia ograniczenia licznika?


1. Podstawowym długiem technologicznym jest sztywne ograniczenie maksymalnego rozmiaru liczby pierwszej, do której można podnieść licznik. W obecnej formie nie można zmienić tej wartości bez rekompilacji kodu (aczkolwiek zastosowanie sita Erastotenesa - a nie np. statycznej listy liczb pierwszych - pozwoliłoby przykładowo na ładowanie ograniczenia z pliku konfiguracyjnego).
2+4. Na potrzeby tak prostej aplikacji wystarczyłby moim zdaniem TableStorage z pojedynczą tabelą, przechowującą liczniki użytkowników jako encje. Jako baza NoSQL TableStorage sprawnie radzi sobie z operacjami dostępu do pojedynczych encji po konkretnym kluczu (tutaj kluczem byłaby zapewne po prostu nazwa licznika). Oprócz tego, TableStorage realizuje wewnętrznie rozkład kluczy pomiędzy wiele partycji, więc nawet przy dużym obciążeniu powinien sprawdzić się pod względem wydajności.
3. To zależy od szczegółowych potrzeb klienta. Najprostsza potrzeba, jaka przychodzi mi do głowy - to "nie chcę, żeby ktoś poza mną mógł modyfikować licznik, który stworzyłem). W takiej sytuacji moglibyśmy do wszystkich operacji modyfikujących dodać propertę Password. Przy tworzeniu licznika solilibyśmy oraz hashowalibyśmy hasło - a później przechowalibyśmy rezultat (wraz z solą) w dodatkowych dwóch propertach (albo kolumnach wyżej wspomnianego TableStorage). Przy kolejnych dostępach do operacji modyfikujących licznik - klient podawałby po prostu hasło jako dodatkowy parametr, a my mając dostęp do soli i hasha (dostęp do których jest dla nas bardzo szybki z perspektywy bazodanowej, bo trzymamy to wszystko nadal w jednej encji) możemy łatwo zwalidować, czy modyfikujący jest osobą, która stworzyła dany licznik.
5. Zastosowane Sito Erastotenesa powinno pozwolić na znaczne podniesienie limitu względem oryginalnych 20000 - ale nadal jesteśmy ograniczeni złożonością pamięciową (i w mniejszym stopniu - czasem inicjalizacji samej struktury przechowującej liczby pierwsze). Z tego co wiem, istnieją probabilistyczne algorytmy do wyszukiwania liczb pierwszych o wielkich rozmiarach - więc możnaby poszukać takich rozwiązać - ale trzeba też uświadomić klientowi, że problem wyszukiwania liczb pierwszych jest nietrywialny i jakieś - nawet jeśli bardzo wysokie - limit zawsze się tu pojawią.